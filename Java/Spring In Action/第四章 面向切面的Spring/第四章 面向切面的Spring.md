# 第四章 面向切面的Spring

[TOC]

## 面向切面要解决的问题

在软件开发中，散布于应用中多处的功能被称为 **横切关注点**，例如事务、安全、日志、权限控制………通常来讲，这些**横切关注点**从概念上是与业务的应用逻辑相分离的。把这些横切关注点与业务逻辑相分离正是面向切面编程所要解决的问题。

横切关注点可以被模块化为特殊的类，这些类被称为**切面**

## 面向切面常用术语

描述切面的常用术语有 ：通知、切点和连接点 。

![通知、切点和连接点](http://zhangzhaolin.oss-cn-beijing.aliyuncs.com/18-8-8/23137316.jpg)

### 通知

在AOP术语中，切面（横切关注点可以被模块化为特殊的类）的工作被称为通知。通知定义了 **切面是什么以及何时使用**，除了描述切面所完成的工作，通知还解决了**何时执行这个工作的问题**。

Spring切面可以应用五种类型的通知 :

- 前置通知 ：在目标方法被 **调用之前** 调用通知功能 
- 后置通知 ：在目标方法 **完成之后** 调用通知，不会关心方法的输出是什么
- 返回通知 ：在目标方法 **成功执行** 之后调用通知
- 异常通知 ：在目标方法 **抛出异常** 后调用通知
- 环绕通知 ：通知包裹了被通知的方法，在目标方法 **调用之前和调用之后** 执行自定义的行为

### 连接点

连接点就是在 **应用执行过程中** 能够 **插入切面** 的一个点

### 切点

一个切面不需要通知应用的所有连接点。切点有助于**缩小切面所通知的连接点**。如果说通知定义了切点是什么以及切点在何时使用的话，那么切点就定义了“何处”。切点的定义会匹配通知所要 **织入** 的一个或者多个连接点。

### 切面

切面是通知和切点的结合。通知和切点共同定义了切面的全部内容——它是什么，在何时和何处完成其功能。

### 引入

引入允许我们向现有类添加新方法或者属性。在无需修改现有的类的情况下，让他们具有新的行为和状态。

### 织入

织入是**把切面应用到目标对象并创建新的代理的过程**。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入 ：

- 编译期 ： 切面在目标类编译时被织入。这种方式需要有特殊的编译器。
- 类加载期 ：切面在目标类加载到JVM时被织入。这种方式需要有特殊的类加载器。
- 运行期 ：切面在应用运行的某个某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式注入切面的。

### 总结

通知包含了需要用于多个应用对象的横切行为（横切关注点）；连接点是程序执行过程中能够应用通知的所有点；切点定义了通知被应用的具体位置（在哪些连接点会得到通知）。

## Spring对AOP的支持

Spring提供了四种类型的AOP支持 ：

- [x] 基于代理的经典Spring AOP
- [ ] 纯POJO切面（借助`aop`命名空间可以将POJO转换为切面，需要XML配置）
- [ ] `@AspectJ`注解驱动的切面（不使用XML来完成功能）
- [ ] 注入式`AspectJ`切面（如果AOP需求超过了简单的方法调用如构造器或者属性拦截，那么你需要考虑使用`AspectJ`来实现切面，适用于Spring各版本）

Spring通知是使用Java编写的，定义通知所应用的切点通常会使用注解或XML编写。

通过在代理类中包裹切面（通知 + 切点），Spring在运行期把切面织入到Spring管理的bean中。如图，代理类封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，**在调用目标bean方法之前，会执行切面逻辑**。

![SPring的切面由包裹了目标对象的代理类实现。代理类处理方法的调用，执行额外的切面逻辑，并调用目标方法](http://zhangzhaolin.oss-cn-beijing.aliyuncs.com/18-8-12/38529126.jpg)

直到应用需要被代理的bean时，Spring才会创建代理对象。

因为Spring基于动态代理，所以Spring只支持方法连接点。Spring缺少对字段连接点的支持，无法让我们创建细粒度的通知，例如拦截对象字段的修改。

## 通过切点来选择连接点

### 使用AspectJ的切点表达式语言

在Spring AOP中，使用`AspectJ`的切点表达式语言定义切点，其中`execution`是最重要的描述符 ：

```java
execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)
            throws-pattern?)
```

除了返回类型、方法名称以及参数列表之外，其余都是可选的（即含有`?`的都是可选的）

- `modifiers-pattern?` ：方法修饰符（public、private、默认、protected）
- `ret-type-pattern` ：方法返回类型
- `declaring-type-pattern?` ：方法类所在路径
- `name-pattern` ：方法名
- `param-pattern` ：方法参数类型，可有一个或者多个，用`(..)`表示零个或者任意个参数，多个参数还可以用`,`分隔，也可以用`(*)`表示匹配任意类型的参数
- `throws-pattern?` ：表示方法抛出的异常

例如 ：

匹配所有的public方法 ：

```java
execution(public * *(..))
```

匹配所有方法名开头为`set`的 ：

```java
execution(* set*(...))
```

匹配定义在`AccountService`接口类中的所有方法

```java
execution(* com.xyz.service.AccountService.*(...))
```





