# 第四章 引入流

## 什么是流

流允许你以声明性方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。流还可以透明地并行处理。

```java
@Data
@AllArgsConstructor
public class Dish {
    private String name;
    private boolean vegetarian;
    private int calories;
    private Type type;

    public enum Type {
        MEAT, FISH, OTHER
    }
}
```

我们需要对菜肴做如下处理：返回低热量的卡路里菜肴名称，并按照卡路里排序 。

```java
List<Dish> menu = Arrays.asList(
                new Dish("pork", false, 800, Dish.Type.MEAT),
                new Dish("beef", false, 700, Dish.Type.MEAT),
                new Dish("chicken", false, 400, Dish.Type.MEAT),
                new Dish("french fries", true, 530, Dish.Type.OTHER),
                new Dish("rice", true, 350, Dish.Type.OTHER),
                new Dish("season fruit", true, 120, Dish.Type.OTHER),
                new Dish("pizza", true, 550, Dish.Type.OTHER),
                new Dish("prawns", false, 300, Dish.Type.FISH),
                new Dish("salmon", false, 450, Dish.Type.FISH)
        );
```

```java
List<String> lowCalories = menu.stream()
                .filter(item -> item.getCalories() <= 400)
                .sorted(Comparator.comparing(Dish::getCalories))
                .map(Dish::getName)
                .collect(Collectors.toList());
```

为了利用多核架构运行这段代码，你只需要将`stream`改为`parallelStream` 。

另外一个需求是 ： 对菜肴类别进行分组处理 ：

```java
Map<Dish.Type, List<Dish>> dishByType = menu.stream().collect(Collectors.groupingBy(Dish::getType));
```

Java8中的API可以让你写出这样的代码 ： 

- 声明性 ： 更简洁、易懂
- 可复合 ： 更灵活
- 可并行 ： 性能更好

## 流简介

🔺『流』的定义 —— 支持**数据处理操作**的『**源生成**的**元素序列**』 。

- 元素序列 ：就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。因为集合是数据结构，所以集合的主要目的是以特定的时间或空间复杂度存储和访问元素（如`ArrayList`与`LinkedList`）。但**流的目的在于表达计算**，比如你前面见到的`filter`、`sorted`和`map` 。集合讲的是数据，流讲的是计算。
- 源 ：流会使用一个提供数据的源，如集合、数组或者输入/输出资源。请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。
- 数据处理操作 ：流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，如`filter`、`map`、`reduce`、`find`、`match`、`sort`等。**流操作可以顺序执行，也可以并行执行**。

下面这段代码列举了卡路里高（大于三百）的食物名称，并只展示前三个（不排序）：

```java
List<String> threeHighCaloriesDishNames = menu.parallelStream()
    									.filter(item->item.getCalories > 300)
    									.map(Dish::getName)
    									.limit(3)
    									.collect(Collectors.toList());
```

在上面代码中，我们对`menu`调用`stream`方法，由菜单得到一个流。<u>数据源</u>就是菜肴列表，它给流提供了一个<u>元素序列</u>。接下来，对流应用一系列数据处理操作：`filter`、`map`、`limit`、`collect`。除了`collect`之外，所有的数据处理操作都会返回另外一个流，这样它们就可以接成一条流水线，于是就可以看作对源的一个查询。最后，`collect`操作开始处理流水线，并返回结果。在调用`collect`之前，没有任何结果产生，实际上根本就没有从`menu`里选择元素。你可以这么理解 ： **链中的方法调用都在排队等待，直到调用`collect`**



