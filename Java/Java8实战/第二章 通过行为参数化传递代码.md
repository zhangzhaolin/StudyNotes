# 第二章 通过行为参数化传递代码

## 什么是行为参数化？

**行为参数化**就是可以帮助你处理频繁变更的需求的一种软件开发模式。

## 应对不断变化的需求

### 筛选绿苹果

想第一章开始的那个例子，从库存中筛选出绿色的苹果：

```java
private static List<Apple> filterGreenApples(List<Apple> appleList){
    List<Apple> result = new ArrayList<>();
    for (Apple apple:appleList){
        if (apple.getColor() == Color.BLUE){
            result.add(apple);
        }
    }
    return result;
}
```

现在，农民想筛选出红苹果，紫苹果，黄苹果……我们可以把苹果的颜色当成另外一个参数 

### 把颜色当成参数

```java
private static List<Apple> filterApplesByColors(List<Apple> appleList,Color color){
    List<Apple> result = new ArrayList<>();
    for (Apple apple:appleList){
        if (apple.getColor() == color){
            result.add(apple);
        }
    }
    return result;
}
```

现在，只需要调用这个方法，就可以满足『筛选不同颜色的苹果』的需求 ：

```java
// 筛选红苹果
filterApplesByColors(inventory,Color.RED);
// 筛选绿苹果
filterApplesByColors(inventory,Color.GREEN);
```

现在，农民跑过来说，他想要区分轻苹果和重苹果，所以你写了下面的方法，来应对不同的重量 ：

```java
private static List<Apple> filterApplesByHeavy(List<Apple> appleList,Double weight){
    List<Apple> result = new ArrayList<>();
    for (Apple apple:appleList){
        if (apple.getWeight() > weight){
            result.add(apple);
        }
    }
    return result;
}
```

我们发现，我们写的这两个方法好像有点类似 。

## 行为参数化

在上述的需求中，我们发现，我们总是在判断苹果的某个属性是否符合条件，例如：『苹果的颜色是绿色的么？』『苹果的重量超过150千克了么？』。我们将返回一个`boolean`值的函数称为**谓词**。

让我们定义一个接口来对选择标准进行建模 ：

```java
public interface ApplePredicate {
    boolean test(Apple o);
}
```

现在，我们可以使用多个实现类，来代表不同的选择标准了，例如：

```java
public class AppleHeavyWeightPredicate implements ApplePredicate {
    @Override
    public boolean test(Apple o) {
        return o.getWeight() > 150;
    }
}
```

```java
public class AppleGreenColorPredicate implements ApplePredicate {
    @Override
    public boolean test(Apple o) {
        return o.getColor() == Color.GREEN;
    }
}
```

![]()